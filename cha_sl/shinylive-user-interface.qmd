---
title: Shinylive User Interface
author: 
  - name:
      given: Miquel
      family: Perello Nieto
    orcid: 0000-0001-8925-424X
    email: miquel.perellonieto@bristol.ac.uk
    affiliations:
      - name: University of Bristol
        city: Bristol
        country: United Kingdom
        postal-code: BS8 1QU
    attributes:
        equal-contributor: False
format: html
filters:
  - shinylive
---

One of the main characteristic of Shinylive is the `User Interface`. It allows
to visualise html outputs, sliders and plots among others.

The following is an example of a slider that is used as an input that can be
accessed by the application, and the output text.

````yaml
```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]

[...] # All the code in the editor
```
````

wich would be rendered as follows


```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]

from shiny import App, ui, render

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 40),
    ui.output_text_verbatim("output_text"),
)

def server(input, output, session):
    @output
    @render.text
    def output_text():
        return f"The value of N*2 is {input.n() * 2}"

app = App(app_ui, server)
```

If the source code is not important, the same application can be shown without
the code by removing the `editor` from the list of components

````yaml
```{shinylive-python}
#| standalone: true
#| components: viewer

[...] # All the code
```
````

which will render as

```{shinylive-python}
#| standalone: true
#| components: viewer

from shiny import App, ui, render

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 40),
    ui.output_text_verbatim("output_text"),
)

def server(input, output, session):
    @output
    @render.text
    def output_text():
        return f"The value of N*2 is {input.n() * 2}"

app = App(app_ui, server)
```

It is also possible to output a plot that can be generated with any package
that generates images. Among the packages built in Pyodide[^1]. The following is
an example using the Matplotlib package.

[^1]: [https://pyodide.org/en/stable/usage/packages-in-pyodide.html](https://pyodide.org/en/stable/usage/packages-in-pyodide.html)

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]

import matplotlib.pyplot as plt
import numpy as np
from shiny import App, render, ui

np.random.seed(42)
x = 50 + 5*np.random.randn(500)

app_ui = ui.page_fluid(
    ui.input_slider("n", "Number of bins", 
                    min=1, max=100, value=20),
    ui.output_plot("plot"),
)

def server(input, output, session):
    @output
    @render.plot(alt="A histogram")
    def plot():
        fig, ax = plt.subplots()
        ax.hist(x, bins=input.n())
        return fig

app = App(app_ui, server)
```

For more complex code it is possible to add multiple files. This is accomplished
by separating the code block with statements like

````yalm
```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]

# Code for the default file (app.py)

## file: utils.py

# Code for the utils.py file
```
````

The following is an example related to binary probability calibration.


```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]

from utils import plot_reliability_diagram
import numpy as np

np.random.seed(42)
scores = np.random.rand(100)
labels = np.random.binomial(1, scores)

import numpy as np
from shiny import App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "Number of bins", 
                    min=1, max=100, value=10),
    ui.h2('Reliability diagram'),
    ui.output_plot("plot"),
)

def server(input, output, session):
    @output
    @render.plot(alt="A histogram")
    def plot():
        fig = plot_reliability_diagram(labels, scores,
                                       n_bins=input.n())
        return fig

app = App(app_ui, server, debug=True)


## file: utils.py
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import matplotlib.ticker as mticker

def get_binned_scores(labels, scores, bins=10):
    '''
    Parameters
    ==========
    labels : array (n_samples, )
        Labels indicating the true class.
    scores : matrix (n_samples, )
        Output probability scores for one or several methods.
    bins : int or list of floats
        Number of bins to create in the scores' space, or list of bin
        boundaries.
    '''
    n_bins = 1
    if isinstance(bins, int):
        n_bins = bins
        bins = np.linspace(0, 1 + 1e-8, n_bins + 1)
    elif isinstance(bins, list) or isinstance(bins, np.ndarray):
        n_bins = len(bins) - 1
        bins = np.array(bins)
        if bins[0] == 0.0:
            bins[0] = 0 - 1e-8
        if bins[-1] == 1.0:
            bins[-1] = 1 + 1e-8

    scores = np.clip(scores, a_min=0, a_max=1)

    bin_idx = np.digitize(scores, bins) - 1

    bin_true = np.bincount(bin_idx, weights=labels,
                           minlength=n_bins)
    bin_pred = np.bincount(bin_idx, weights=scores,
                           minlength=n_bins)
    bin_total = np.bincount(bin_idx, minlength=n_bins)

    zero_idx = bin_total == 0
    avg_true = np.empty(bin_total.shape[0])
    avg_true.fill(np.nan)
    avg_true[~zero_idx] = np.divide(bin_true[~zero_idx],
                                    bin_total[~zero_idx])
    avg_pred = np.empty(bin_total.shape[0])
    avg_pred.fill(np.nan)
    avg_pred[~zero_idx] = np.divide(bin_pred[~zero_idx],
                                    bin_total[~zero_idx])
    return avg_true, avg_pred, bin_true, bin_total
    
def plot_reliability_diagram(labels, scores, n_bins=10):
    bins = np.linspace(0, 1 + 1e-8, n_bins + 1)

    avg_true, avg_pred, bin_true, bin_total = get_binned_scores(
            labels, scores, bins=bins)

    zero_idx = bin_total == 0
    fig = plt.figure()
    ax1 = fig.add_subplot()
    fig, axs = plt.subplots(2, 1,
                            gridspec_kw={'height_ratios': [4, 1]})
    axs[0].bar(x=bins[:-1][~zero_idx], height=avg_true[~zero_idx],
                        align='edge', width=(bins[1:] - bins[:-1])[~zero_idx],
                        edgecolor='black')
    axs[0].scatter(avg_pred, avg_true)
    axs[0].plot([0, 1], [0, 1], '--', color='red')

    axs[0].set_xlim([0, 1])
    axs[0].set_ylim([0, 1])
    axs[0].set_ylabel('Fraction of positives')
    axs[0].grid(True)
    axs[0].set_axisbelow(True)

    axs[1].hist(scores, range=(0, 1),
             bins=bins,
             histtype="bar",
             lw=1,
             edgecolor='black')

    axs[1].set_xlim([0, 1])
    axs[1].set_ylabel('Count')
    axs[1].set_xlabel('Scores')


    weights = bin_total[~zero_idx]/sum(bin_total)
    ece = sum(np.abs(avg_pred - avg_true)[~zero_idx]*weights)
    fig.suptitle(f'Expected Calibration Error = {ece:0.3f}')
    return fig
```
